#include <stdio.h>

// Fibonacci series using recursion
int fibonacci1 (int n)
{
  if (n <= 1)
    return n;
  return fibonacci1(n - 1) + fibonacci1(n - 2);
}

// Fibonacci series using dynamic programming
int fibonacci2 (int n)
{
  // Declare an array to store Fibonacci numbers
  int f[n + 1], i;
  // 0th and 1st number of the series are 0 and 1
  f[0] = 0;
  f[1] = 1;

  for (i = 2; i <= n; i++)
    {
      // Add the previous 2 numbers in the series and store it
      f[i] = f[i - 1] + f[i - 2];
    }
  return f[n];
}

// Fibonacci series using space uptimized method
int fibonacci3 (int n)
{
  int a = 0, b = 1, c, i;
  if (n == 0)
    return a;
  for (i = 2; i <= n; i++)
    {
      c = a + b;
      a = b;
      b = c;
    }
  return b;
}

// Using power of the matrix {{1,1},{1,0}}

/* Helper function that multiplies 2 matrices F and M of size 2*2, and
 * puts the multiplicatio result back to F[][] */
void multiply (int F[2][2], int M[2][2]);

/* Helper function that calculates F[][] raise th the power n and puts the 
 * result in F[][]
 * Note that this function is designed only for fibonacci4() and won't as
 * general power function  */
void power (int F[2][2], int n);

int fibonacci4 (int n)
{
  int F[2][2] = {{1,1},{1,0}};
  if (n == 0)
    return 0;
  power (F, n - 1);
  return F[0][0];
}

void multiply (int F[2][2], int M[2][2])
{
  int x = F[0][0] * M[0][0] + F[0][1] * M[1][0];
  int y = F[0][0] * M[0][1] + F[0][1] * M[1][1];
  int z = F[1][0] * M[0][0] + F[1][1] * M[1][0];
  int w = F[1][0] * M[0][1] + F[1][1] * M[1][1];

  F[0][0] = x;
  F[0][1] = y;
  F[1][0] = z;
  F[1][1] = w;
}

void power (int F[2][2], int n)
{
  int i;
  int M[2][2] = {{1,1},{1,0}};

  // n - 1 times multiply the matrix to {{1,0},{0,1}}
  for (i = 2; i <= n; i++)
    multiply (F, M);
}

int main()
{
  printf("%d\n", fibonacci1(145));
  //  printf("%d\n", fibonacci2(145));
  //  printf("%d\n", fibonacci3(145));
  //  printf("%d\n", fibonacci4(145));
  return 0;
}
